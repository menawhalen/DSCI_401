---
title: "Wrangling 2: Joins"
format: html
editor: visual
---

## Introduction: Why Joins Matter

In many real-world datasets, information is stored in multiple tables. For example:
- The `nycflights13` dataset contains flight information, airlines, airports, and planes all in separate tables.
- The CTA ridership and stops datasets contain different types of information about Chicago train stations.

To gain insights, we often need to **combine** these tables using a common key.

### Review
- Recall: `mutate()`, `select()`, `filter()`, and `group_by()` are used for manipulating a *single* dataset.
- `join` functions let us combine *multiple* datasets.

**Warm-Up:**
> If one dataset lists `station_id` and `rides` and another lists `station_id` and `line`, how could we find which line has the most rides?

---

## Conceptual Overview of Joins

| Join Type | Description | Example Use |
|------------|--------------|--------------|
| `inner_join()` | Keeps rows with matching keys in both datasets | Find only matching station IDs |
| `left_join()` | Keeps all rows from the left dataset | Keep all ridership data, even if no station info |
| `right_join()` | Keeps all rows from the right dataset | Keep all stops, even if no ridership info |
| `full_join()` | Keeps all rows from both datasets | Combine everything, fill gaps with NA |

### Example with Small Tables

```{r}
library(tidyverse)

x <- tibble(id = c(1, 2, 3), value_x = c("A", "B", "C"))
y <- tibble(id = c(2, 3, 4), value_y = c("D", "E", "F"))

inner_join(x, y, by = "id")
left_join(x, y, by = "id")
right_join(x, y, by = "id")
full_join(x, y, by = "id")
```

**Discussion:**
- What happens to rows with no match?
- How does `NA` indicate missing matches?

---

## The `nycflights13` Example

We'll use the `nycflights13` package, which contains several related tables:

- `flights`: flight details
- `airlines`: airline codes and names
- `airports`: airport codes and locations
- `planes`: airplane tail numbers and details

```{r}
library(nycflights13)

head(flights)
head(airlines)
```

### Joining Flights with Airlines

We can connect the airline codes in `flights` with their full names in `airlines`:

```{r}
flights %>%
  left_join(airlines, by = "carrier") %>%
  select(carrier, name, flight, origin, dest, dep_delay, arr_delay) %>%
  head()
```

> What does `by = "carrier"` do? Why might a left join be appropriate here?

### Joining Flights with Airports


```{r examine_data, message=FALSE, warning=FALSE, echo=FALSE}
library(tidyverse)
library(mdsr)
library(nycflights13)

head(airlines)
head(flights)

```

```{r inner}
#Tidyverse way
flights_joined <- flights %>% 
  inner_join(airlines, by = c("carrier" = "carrier"))
glimpse(flights_joined)
 
flights_joined %>% 
  select(carrier, name, flight, origin, dest) %>% 
  head(3)
```

"In an inner_join(), the result set contains only those rows that have matches in both tables. In this case, all of the rows in flights have exactly one corresponding entry in airlines, so the number of rows in flights_joined is the same as the number of rows in flights (this will not always be the case)."

***It is always a good idea to carefully check that the number of rows returned by a join operation is what you expected. In particular, you should carefully check for rows in one table that matched to more than one row in the other table***

### Left Join

A left join includes all rows from the left dataset and the matching rows from the right dataset. If there's no match, the columns from the right dataset will be filled with NA. Here the rows of the first table are always returned, regardless of whether there is a match in the second table.

```         
left_joined_data <- dataset1 %>%
  left_join(dataset2, by = "common_column")
```

### Practice with Flights Data

```{r left}
#Airports in the pacific time zone only 
airports_pt <- airports %>%
  filter(tz == -8) %>% 
  select(faa, name, tz)

nrow(airports_pt)
head(airports_pt)
  
#If we do inner join
nyc_dests_pt <- flights %>% 
  inner_join(airports_pt, by = c("dest" = "faa")) %>% 
  select(name, tz, dest, dep_time,sched_dep_time, arr_time, sched_arr_time, carrier)

head(nyc_dests_pt)
 
#Notice these are different.  
#key variable needs to be in BOTH data sets to get returned.  
nrow(flights)
nrow(nyc_dests_pt)
 
nyc_dests <- flights %>% 
  left_join(airports_pt, by = c("dest" = "faa"))
 
#Notice these are the same!
nrow(flights)
nrow(nyc_dests)


nyc_dests %>%
  summarize(
    num_flights = n(),
    num_flights_pt = sum(!is.na(name)),
    num_flights_not_pt = sum(is.na(name))
  )
```

### Full Join

A full join includes all rows from both datasets. Columns from the dataset with missing values will be filled with NA where there's no match.

```         
full_joined_data <- dataset1 %>%
  full_join(dataset2, by = "common_column")
  
```

There is also a right join but this is much less common. A right join is the opposite of a left join. It includes all rows from the right dataset and the matching rows from the left dataset.

### Practice with Flights Data

```{r}
# Right Join: Keeping all airports in the pacific time zone, matching if possible
nyc_dests_right <- flights %>% 
  right_join(airports_pt, by = c("dest" = "faa"))

# Full Join: Keeping all destinations and airports, filling with NA where no match
nyc_dests_full <- flights %>% 
  full_join(airports_pt, by = c("dest" = "faa"))

# Summary of the results
summary_inner <- nyc_dests_pt %>%
  summarize(num_flights = n())

summary_left <- nyc_dests %>%
  summarize(
    num_flights = n(),
    num_flights_pt = sum(!is.na(name)),
    num_flights_not_pt = sum(is.na(name))
  )

summary_right <- nyc_dests_right %>%
  summarize(num_airports = n())

summary_full <- nyc_dests_full %>%
  summarize(num_rows = n(), 
            num_airports = sum(!is.na(name)))

# Display the summaries
summary_inner
summary_left
summary_right
summary_full

```

### Join by multiple columns

The `by` argument specifies the column(s) that should be used for matching. These join functions work well when the datasets have a shared column containing the same type of data (e.g., IDs or keys).

You can use multiple column names to define the matching conditions.

```         
# Syntax
inner_join(df1, df2, by=c('x1'='y1', 'x2'='y2'))
```

Example Code

```{r example_mult}
# Create emp Data Frame
emp_df=data.frame(
  emp_id=c(1,2,3,4,5,6),
  name=c("Smith","Rose","Williams","Jones","Brown","Brown"),
  superior_emp_id=c(-1,1,1,2,2,2),
  dept_id=c(10,20,10,10,40,50),
  dept_branch_id= c(101,102,101,101,104,105)
)

# Create dept Data Frame
dept_df=data.frame(
  dept_id=c(10,20,30,40),
  dept_name=c("Finance","Marketing","Sales","IT"),
  dept_branch_id= c(101,102,103,104)
)

emp_df %>% 
  inner_join(dept_df, 
        by=c('dept_id'='dept_id', 
             'dept_branch_id'='dept_branch_id'))

```

## Hands-On Practice with CTA Data (Real-World Example)

We’ll use two real datasets: `CTA_ridership.csv` and `CTA_stops_long.csv`.

```{r}
library(janitor)

rides <- read_csv("../midterm/midterm/data/CTA_ridership.csv") %>%
  mutate(station_id = as.character(station_id))

stops <- read_csv("../midterm/midterm/data/CTA_stops_long.csv") %>%
  clean_names() %>%
  mutate(stop_id = as.character(stop_id))
```

### Example 1: Join by Station Name

```{r}
left_join(rides, stops, by = c("stationname" = "station_name"))
```

> What happens when names don’t match exactly? Why might that cause issues?

### Example 2: Join by Station ID

```{r}
left_join(rides, stops, by = c("station_id" = "stop_id"))
```

Compare the row counts between the joins:

```{r}
nrow(inner_join(rides, stops, by = c("stationname" = "station_name")))
nrow(left_join(rides, stops, by = c("stationname" = "station_name")))
```

> Why do the results differ? Which join preserves all ridership data?

---

## Troubleshooting and Best Practices

### Mismatched Column Names
```{r}
left_join(rides, stops, by = c("stationname" = "station_name"))
```

### Duplicate Keys
If there are duplicate keys, rows can multiply unexpectedly.

### Checking for Missing Matches
```{r}
anti_join(rides, stops, by = c("stationname" = "station_name"))
```

> What does this tell us about stations that appear in `rides` but not `stops`?

---

## Advanced Joins

### Filtering Joins
- `semi_join(x, y)`: keeps rows in `x` that have a match in `y`.
- `anti_join(x, y)`: keeps rows in `x` that do *not* have a match in `y`.

### Binding Rows or Columns
- `bind_rows()` adds more observations.
- `bind_cols()` adds more variables.

---

## Practice Problems

1. Using `flights` and `airlines`, which carrier has the most flights?
2. Using `flights` and `airports`, what is the average delay by destination airport?
3. Using `rides` and `stops`, which station has the most lines?
4. Visualize the number of stations by line:

5. Check your join results:
   - Did the number of rows change after joining?
   - Were there any missing values introduced?

---

## Wrap-Up and Reflection


- When should you use a `left_join` vs. an `inner_join`?
- How can you verify your join worked correctly?
- What information might you lose in a join?



---

**Next Week:**  
We’ll move from joins to *reshaping* data with `pivot_longer()` and `pivot_wider()`.